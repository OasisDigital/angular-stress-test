const fs = require("fs");
const mkdirp = require('mkdirp');

const baseDir = "./";
const randValue = Math.round(Math.random() * 10000);

// Global state - the software runs then exits, so why be more complex?

const modules: Module[] = [];
const components: Component[] = [];

function fmt(n) {
  let result = n.toString();
  // Stay clear of the left-pad chaos!
  while (result.length < 6) {
    result = "0" + result;
  }
  return result;
}

abstract class Writeable {
  abstract write(deterministic: boolean): void;
}

class Component extends Writeable {

  module: Module;
  uses: Component[] = [];

  constructor(private id: number) {
    super();
  }

  get name() {
    return `My${fmt(this.id)}Component`;
  }

  get fileName() {
    return `my.${fmt(this.id)}.component`;
  }

  get selector() {
    return `app-comp-${fmt(this.id)}`;
  }

  useChildComponent(c: Component) {
    this.uses.push(c);
  }

  write(deterministic: boolean) {

    let ts = `// Code generated by angular-stress-test

import { Component, Input } from '@angular/core';\n`;

    ts += `
@Component({
  selector: '${this.selector}',
  templateUrl: './${this.fileName}.html'
})
export class ${this.name} {
  @Input() parentName: string;
  myName = '${this.name}';
`;

    if (!deterministic) {
      ts += `
      // Random variable to make this component different on each generation
      variable${randValue}: number = ${randValue};
    `;
    }
    ts += `}
`;

    let html = `<div>
    <span>component {{myName}}<span *ngIf="parentName">,
      parent is {{parentName}}</span></span>`;

    if (!deterministic) {
      html += `
        <small>[${ randValue}]</small>`;
    }

    html += `
        <div style="padding-left: 15px">`;

    this.uses.forEach(subComp =>
      html += `
        <${subComp.selector} [parentName]="myName"></${subComp.selector}>`
    )

    html += `
    </div></div>`

    mkdirp.sync(`${baseDir}${this.module.name}`);
    fs.writeFileSync(`${baseDir}${this.module.name}/${this.fileName}.ts`, ts);
    fs.writeFileSync(`${baseDir}${this.module.name}/${this.fileName}.html`, html);
  }
}

class Module extends Writeable {

  private components: Component[] = [];
  exportedComponent: Component;

  constructor(private moduleId: number) {
    super();
  }

  get name() {
    return 'Module' + fmt(this.moduleId)
  }

  get fileName() {
    return `${baseDir}${this.name}/${this.name}.module`;
  }

  addComponent(c: Component) {
    this.components.push(c);
    c.module = this;
    if (!this.exportedComponent) {
      this.exportedComponent = c;
    }
  }

  write(deterministic: boolean) {
    let ts = `// Code generated by angular-stress-test

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

`;
    this.components.forEach(c =>
      ts += `import { ${c.name} } from './${c.fileName}';\n`
    );
    ts += `
@NgModule({
  declarations: [`;

    this.components.forEach(c =>
      ts += `\n    ${c.name},`
    );
    ts += `
  ],
  imports: [CommonModule],
  exports: [`;
    ts += `\n    ${this.exportedComponent.name},`;
    ts += `
  ]
})
export class ${this.name} { }
`;

    mkdirp.sync(`${baseDir}${this.name}`);
    const moduleFileName = `${baseDir}${this.name}/${this.name}.module`;
    fs.writeFileSync(moduleFileName + '.ts', ts);
  }
}

function generateModules(nModules, nComponents) {
  const componentsInModule = new Array(nModules);
  componentsInModule.fill(0);
  for (let c = 0; c < nComponents; c++) {
    componentsInModule[c % nModules]++;
  }

  let nextComponentNumber = 0;
  for (let m = 0; m < nModules; m++) {
    const module = new Module(m);
    modules.push(module);
    const componentsInThisModule = [];
    const n = componentsInModule[m];
    for (let i = 1; i <= n; i++) {
      componentsInThisModule.push(new Component(nextComponentNumber++));
    }

    for (let i = 1; i <= n; i++) {
      const c = componentsInThisModule[i - 1];
      module.addComponent(c);
      components.push(c);

      const left = 2 * i;
      const right = 2 * i + 1;

      if (left <= n) {
        c.useChildComponent(componentsInThisModule[left - 1]);
      }
      if (right <= n) {
        c.useChildComponent(componentsInThisModule[right - 1]);
      }
    }
  }
}

function generateAppComponent() {
  const ts = `// Code generated by angular-stress-test

import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent { }
`;

  fs.writeFileSync(baseDir + "app.component.ts", ts);

  let html = `
<h1>Angular App with ${modules.length + 1} modules and ${components.length + 1} components</h1>
`;
  modules.forEach(m => {
    const sel = m.exportedComponent.selector;
    html += `<${sel}></${sel}>\n`;
  });
  fs.writeFileSync(baseDir + "app.component.html", html);

}

function generateAppModule() {
  let ts = `// Code generated by angular-stress-test

import { NgModule } from '@angular/core';
import { BrowserModule  } from '@angular/platform-browser';

import { AppComponent } from './app.component';
`;

  modules.forEach(m => {
    ts += `import { ${m.name} } from '${m.fileName}';\n`;
  });

  ts += `
@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
`;
  modules.forEach(m => {
    ts += `    ${m.name},\n`;
  });
  ts += `],
  bootstrap: [
    AppComponent
  ]
})
export class AppModule { }
`;

  fs.writeFileSync(baseDir + "app.module.ts", ts);
}

function generate(nModules, nComponents, deterministic) {
  generateModules(nModules - 1, nComponents - 1);

  modules.forEach(m => m.write(deterministic));
  components.forEach(c => c.write(deterministic));

  generateAppComponent();  // + 1 component
  generateAppModule();  // + 1 module
}

module.exports = generate;
